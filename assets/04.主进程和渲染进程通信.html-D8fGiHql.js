import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as t,b as a}from"./app-DPOi7EM3.js";const n={};function l(h,i){return e(),t("div",null,i[0]||(i[0]=[a(`<h1 id="主进程和渲染进程通信" tabindex="-1"><a class="header-anchor" href="#主进程和渲染进程通信"><span>主进程和渲染进程通信</span></a></h1><p>在多进程的应用中，进程之间的通信是必不可少的。</p><p>进程间通信，英语叫做 interprocess communication，简称叫做 IPC。这个 IPC 进程通信机制是由操作系统所提供的一种机制，允许应用中不同的进程之间进行一个交流。</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2023-12-14-050520.png" alt="image-20231214130520467" style="zoom:50%;"><p>在 Electron 中，我们需要关注两类进程间的通信：</p><ul><li>主进程和渲染进程之间的通信</li><li>渲染进程彼此之间的通信</li></ul><p>在 Electron 中，已经为我们提供了对应的模块 ipcMain 和 ipcRenderer 来实现这两类进程之间的通信。</p><p><strong>ipcMain模块</strong></p><ul><li>ipcMain.on(channel, listener) <ul><li>这个很明显是一个监听事件，on 方法监听 channel 频道所触发的事件</li><li>listener 是一个回调函数，当监听的频道有新消息抵达时，会执行该回调函数 <ul><li>listener(event, args...) <ul><li>event 是一个事件对象</li><li>args 是一个参数列表</li></ul></li></ul></li></ul></li><li>ipcMain.once(channel, listener)：和上面 on 的区别在于 once 只会监听一次</li><li>ipcMain.removeListener(channel, listener)：移除 on 方法所绑定的事件监听。</li></ul><p>具体可以参阅：https://www.electronjs.org/docs/latest/api/ipc-main</p><p><strong>ipcRenderer模块</strong></p><p>基本上和上面的主进程非常的相似。</p><ul><li><p>ipcRenderer.on(channel, listener)</p><ul><li>和上面主进程的 on 方法用法一样</li></ul></li><li><p>ipcRenderer.send(channel, ...args)</p><ul><li>此方法用于向主进程对应的 channel 频道发送消息。</li><li>注意 send 方法传递的内容是被序列化了的，所以并非所有数据类型都支持</li></ul></li></ul><p>这两个模块实际上是基于 Node.js 里面 EventEmitter 模块实现的。例如：</p><div class="language-js" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// index.js</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> event</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;./event&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 触发事件</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">event</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">emit</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;some_event&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre></div><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// event.js</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> EventEmitter</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> require</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;events&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">EventEmitter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> event</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> EventEmitter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 监听自定义事件</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">event</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">on</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;some_event&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, () </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">  console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;事件已触发&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">module</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">exports</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> event</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,16)]))}const k=s(n,[["render",l],["__file","04.主进程和渲染进程通信.html.vue"]]),o=JSON.parse('{"path":"/code/electron/04.%E4%B8%BB%E8%BF%9B%E7%A8%8B%E5%92%8C%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1.html","title":"主进程和渲染进程通信","lang":"zh-CN","frontmatter":{"title":"主进程和渲染进程通信","icon":"Dxuanzhuan","date":"2024-12-17T00:00:00.000Z","category":"Electron","head":[["meta",{"name":"keywords","content":"Electron|桌面端"}],["meta",{"property":"og:url","content":"https://mister-duan.github.io/code/electron/04.%E4%B8%BB%E8%BF%9B%E7%A8%8B%E5%92%8C%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1.html"}],["meta",{"property":"og:site_name","content":"Mister.Duan"}],["meta",{"property":"og:title","content":"主进程和渲染进程通信"}],["meta",{"property":"og:description","content":"主进程和渲染进程通信 在多进程的应用中，进程之间的通信是必不可少的。 进程间通信，英语叫做 interprocess communication，简称叫做 IPC。这个 IPC 进程通信机制是由操作系统所提供的一种机制，允许应用中不同的进程之间进行一个交流。 image-20231214130520467 在 Electron 中，我们需要关注两类进程..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-17T14:47:36.000Z"}],["meta",{"property":"article:published_time","content":"2024-12-17T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-17T14:47:36.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"主进程和渲染进程通信\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-12-17T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-17T14:47:36.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mister.Duan\\",\\"url\\":\\"https://mister-duan.github.io\\"}]}"],["link",{"rel":"alternate","type":"application/atom+xml","href":"https://mister-duan.github.io/atom.xml","title":"Mister.Duan Atom Feed"}],["link",{"rel":"alternate","type":"application/json","href":"https://mister-duan.github.io/feed.json","title":"Mister.Duan JSON Feed"}],["link",{"rel":"alternate","type":"application/rss+xml","href":"https://mister-duan.github.io/rss.xml","title":"Mister.Duan RSS Feed"}]],"description":"主进程和渲染进程通信 在多进程的应用中，进程之间的通信是必不可少的。 进程间通信，英语叫做 interprocess communication，简称叫做 IPC。这个 IPC 进程通信机制是由操作系统所提供的一种机制，允许应用中不同的进程之间进行一个交流。 image-20231214130520467 在 Electron 中，我们需要关注两类进程..."},"headers":[],"git":{"createdTime":1734446856000,"updatedTime":1734446856000,"contributors":[{"name":"dss","email":"duanshuaishuai@pharmcube.com","commits":1}]},"readingTime":{"minutes":1.61,"words":483},"filePathRelative":"code/electron/04.主进程和渲染进程通信.md","localizedDate":"2024年12月17日","excerpt":"","autoDesc":true}');export{k as comp,o as data};
